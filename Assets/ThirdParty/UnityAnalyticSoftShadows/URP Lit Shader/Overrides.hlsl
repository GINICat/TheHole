TEXTURE2D(_UASSTexture);
SAMPLER(sampler_UASSTexture);


half3 LightingPhysicallyBased_(BRDFData brdfData, BRDFData brdfDataClearCoat, Light light, half3 normalWS, half3 viewDirectionWS, half clearCoatMask, bool specularHighlightsOff, float2 screenUV)
{
	float4 uass = SAMPLE_TEXTURE2D_X(_UASSTexture, sampler_UASSTexture, screenUV);

    // Note: Technically this is slightly incorrect, as we apply shadow to /all/ lights, thus overapplying it. But it would take way too much data storage to do this in a better way, sacrificing performance.
    // So for example if you have point lights trying to brighten a shadow generated by a directional light it will be hard to brighten because the point lights will be shadow-darkened here too,
    // so if that is your scene's use case, you can replace LightingPhysicallyBased_ with LightingPhysicallyBased on lines in this file that don't call this function with mainLight but additional lights.
    
	//light.shadowAttenuation *= uass.x;
    light.color *= uass.rgb;
    
	return LightingPhysicallyBased(brdfData, brdfDataClearCoat, light.color, light.direction, light.distanceAttenuation * light.shadowAttenuation, normalWS, viewDirectionWS, clearCoatMask, specularHighlightsOff);
}

// The only change is "LightingPhysicallyBased(...)" -> "LightingPhysicallyBased_(... , inputData.normalizedScreenSpaceUV)"

#if UNITY_VERSION >= 202220
half4 UniversalFragmentPBR_(InputData inputData, SurfaceData surfaceData)
{
    #if defined(_SPECULARHIGHLIGHTS_OFF)
    bool specularHighlightsOff = true;
    #else
    bool specularHighlightsOff = false;
    #endif
    BRDFData brdfData;

    // NOTE: can modify "surfaceData"...
    InitializeBRDFData(surfaceData, brdfData);

    #if defined(DEBUG_DISPLAY)
    half4 debugColor;

    if (CanDebugOverrideOutputColor(inputData, surfaceData, brdfData, debugColor))
    {
        return debugColor;
    }
    #endif

    // Clear-coat calculation...
    BRDFData brdfDataClearCoat = CreateClearCoatBRDFData(surfaceData, brdfData);
    half4 shadowMask = CalculateShadowMask(inputData);
    AmbientOcclusionFactor aoFactor = CreateAmbientOcclusionFactor(inputData, surfaceData);
    uint meshRenderingLayers = GetMeshRenderingLayer();
    Light mainLight = GetMainLight(inputData, shadowMask, aoFactor);

    // NOTE: We don't apply AO to the GI here because it's done in the lighting calculation below...
    MixRealtimeAndBakedGI(mainLight, inputData.normalWS, inputData.bakedGI);

    LightingData lightingData = CreateLightingData(inputData, surfaceData);

    lightingData.giColor = GlobalIllumination(brdfData, brdfDataClearCoat, surfaceData.clearCoatMask,
                                              inputData.bakedGI, aoFactor.indirectAmbientOcclusion, inputData.positionWS,
                                              inputData.normalWS, inputData.viewDirectionWS, inputData.normalizedScreenSpaceUV);
#ifdef _LIGHT_LAYERS
    if (IsMatchingLightLayer(mainLight.layerMask, meshRenderingLayers))
#endif
    {
        lightingData.mainLightColor = LightingPhysicallyBased_(brdfData, brdfDataClearCoat,
                                                              mainLight,
                                                              inputData.normalWS, inputData.viewDirectionWS,
                                                              surfaceData.clearCoatMask, specularHighlightsOff, inputData.normalizedScreenSpaceUV);
    }

    #if defined(_ADDITIONAL_LIGHTS)
    uint pixelLightCount = GetAdditionalLightsCount();

    #if USE_FORWARD_PLUS
    for (uint lightIndex = 0; lightIndex < min(URP_FP_DIRECTIONAL_LIGHTS_COUNT, MAX_VISIBLE_LIGHTS); lightIndex++)
    {
        FORWARD_PLUS_SUBTRACTIVE_LIGHT_CHECK

        Light light = GetAdditionalLight(lightIndex, inputData, shadowMask, aoFactor);

#ifdef _LIGHT_LAYERS
        if (IsMatchingLightLayer(light.layerMask, meshRenderingLayers))
#endif
        {
            lightingData.additionalLightsColor += LightingPhysicallyBased_(brdfData, brdfDataClearCoat, light,
                                                                          inputData.normalWS, inputData.viewDirectionWS,
                                                                          surfaceData.clearCoatMask, specularHighlightsOff, inputData.normalizedScreenSpaceUV);
        }
    }
    #endif

    LIGHT_LOOP_BEGIN(pixelLightCount)
        Light light = GetAdditionalLight(lightIndex, inputData, shadowMask, aoFactor);

#ifdef _LIGHT_LAYERS
        if (IsMatchingLightLayer(light.layerMask, meshRenderingLayers))
#endif
        {
            lightingData.additionalLightsColor += LightingPhysicallyBased_(brdfData, brdfDataClearCoat, light,
                                                                          inputData.normalWS, inputData.viewDirectionWS,
                                                                          surfaceData.clearCoatMask, specularHighlightsOff, inputData.normalizedScreenSpaceUV);
        }
    LIGHT_LOOP_END
    #endif

    #if defined(_ADDITIONAL_LIGHTS_VERTEX)
    lightingData.vertexLightingColor += inputData.vertexLighting * brdfData.diffuse;
    #endif

    return CalculateFinalColor(lightingData, surfaceData.alpha);
}
#else
half4 UniversalFragmentPBR_(InputData inputData, SurfaceData surfaceData)
{
#if defined(_SPECULARHIGHLIGHTS_OFF)
	bool specularHighlightsOff = true;
#else
	bool specularHighlightsOff = false;
#endif
	BRDFData brdfData;

	// NOTE: can modify "surfaceData"...
	InitializeBRDFData(surfaceData, brdfData);

#if defined(DEBUG_DISPLAY)
	half4 debugColor;

	if (CanDebugOverrideOutputColor(inputData, surfaceData, brdfData, debugColor))
	{
		return debugColor;
	}
#endif

	// Clear-coat calculation...
	BRDFData brdfDataClearCoat = CreateClearCoatBRDFData(surfaceData, brdfData);
	half4 shadowMask = CalculateShadowMask(inputData);
	AmbientOcclusionFactor aoFactor = CreateAmbientOcclusionFactor(inputData, surfaceData);
	uint meshRenderingLayers = GetMeshRenderingLightLayer();
	Light mainLight = GetMainLight(inputData, shadowMask, aoFactor);

	// NOTE: We don't apply AO to the GI here because it's done in the lighting calculation below...
	MixRealtimeAndBakedGI(mainLight, inputData.normalWS, inputData.bakedGI);

	LightingData lightingData = CreateLightingData(inputData, surfaceData);

	lightingData.giColor = GlobalIllumination(brdfData, brdfDataClearCoat, surfaceData.clearCoatMask,
		inputData.bakedGI, aoFactor.indirectAmbientOcclusion, inputData.positionWS,
		inputData.normalWS, inputData.viewDirectionWS);

	if (IsMatchingLightLayer(mainLight.layerMask, meshRenderingLayers))
	{
		lightingData.mainLightColor = LightingPhysicallyBased_(brdfData, brdfDataClearCoat,
			mainLight,
			inputData.normalWS, inputData.viewDirectionWS,
			surfaceData.clearCoatMask, specularHighlightsOff, inputData.normalizedScreenSpaceUV);
	}

#if defined(_ADDITIONAL_LIGHTS)
	uint pixelLightCount = GetAdditionalLightsCount();

#if USE_CLUSTERED_LIGHTING
	for (uint lightIndex = 0; lightIndex < min(_AdditionalLightsDirectionalCount, MAX_VISIBLE_LIGHTS); lightIndex++)
	{
		Light light = GetAdditionalLight(lightIndex, inputData, shadowMask, aoFactor);

		if (IsMatchingLightLayer(light.layerMask, meshRenderingLayers))
		{
			lightingData.additionalLightsColor += LightingPhysicallyBased_(brdfData, brdfDataClearCoat, light,
				inputData.normalWS, inputData.viewDirectionWS,
				surfaceData.clearCoatMask, specularHighlightsOff, inputData.normalizedScreenSpaceUV);
		}
	}
#endif

	LIGHT_LOOP_BEGIN(pixelLightCount)
		Light light = GetAdditionalLight(lightIndex, inputData, shadowMask, aoFactor);

	if (IsMatchingLightLayer(light.layerMask, meshRenderingLayers))
	{
		lightingData.additionalLightsColor += LightingPhysicallyBased_(brdfData, brdfDataClearCoat, light,
			inputData.normalWS, inputData.viewDirectionWS,
			surfaceData.clearCoatMask, specularHighlightsOff, inputData.normalizedScreenSpaceUV);
	}
	LIGHT_LOOP_END
#endif

#if defined(_ADDITIONAL_LIGHTS_VERTEX)
		lightingData.vertexLightingColor += inputData.vertexLighting * brdfData.diffuse;
#endif

	return CalculateFinalColor(lightingData, surfaceData.alpha);
}
#endif